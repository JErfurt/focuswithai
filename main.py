# ---------------------------------------------------------------
# Скрипт: Window Focus Reminder
# Автор: JErfurt
# Дата: 16 октября 2024 года
# Описание: Скрипт отслеживает активные окна и напоминает пользователю
#           о необходимости вернуться к рабочему окну, если он отвлекся.
#
# Лицензия: MIT License
#
# Copyright (c) 2024 JErfurt
#
# Данная работа предоставляется "как есть", без каких-либо гарантий.
# Вы можете использовать, копировать, изменять и распространять её 
# для любых целей при указании оригинального автора.
#
# Этот проект использует библиотеки, лицензированные под MIT, BSD и LGPL лицензиями.
# ---------------------------------------------------------------

import pygetwindow as gw
import time
from pywinauto.application import Application
import pygame
import pyttsx3
import edge_tts
from pydub import AudioSegment
from io import BytesIO
import asyncio

# Инициализация звука
pygame.mixer.init()

# Инициализация голосового движка
engine = pyttsx3.init()

# Задаем список целевых приложений
target_apps = ["Unity", "Visual Studio Code", "Android Studio"]
# Время бездействия в "нецелевых" окнах перед напоминанием, в секундах
reminder_interval = 30
# Время бездействия перед отправкой запроса к AI (punishment), в секундах
punishment_interval = 60

# Время последнего бездействия
last_active_time = time.time()
# Переменная для хранения последнего активного целевого окна
last_target_window = None

# Функция для проверки текущего активного окна
def get_active_window_title():
    window = gw.getActiveWindow()
    if window:
        return window.title
    return None

# Функция для воспроизведения аудио файла
def play_reminder_sound():
    try:
        sound_file = "H_WARNING.mp3"  # Укажи путь к твоему звуковому файлу
        pygame.mixer.music.load(sound_file)
        pygame.mixer.music.play()
        print("[INFO] Напоминание: Воспроизведение звука.")
    except Exception as e:
        print(f"[ERROR] Ошибка при воспроизведении звука: {e}")

# Функция для переключения обратно на последнее целевое окно
def switch_back_to_last_target():
    global last_target_window
    if last_target_window:
        print(f"[INFO] Попытка переключиться на последнее активное окно: {last_target_window}")
        try:
            # Подключаемся к окну через pywinauto
            app_window = Application(backend='uia').connect(title=last_target_window, timeout=10)
            app_window.top_window().set_focus()
            print(f"[INFO] Успешно переключились на окно: {last_target_window}")
        except Exception as e:
            print(f"[ERROR] Ошибка при переключении на {last_target_window}: {e}")
    else:
        print("[INFO] Последнее целевое окно не найдено. Невозможно переключиться.")

import edge_tts

# Функция для озвучивания текста
async def speak_text(text, voice="ru-RU-SvetlanaNeural"):
    # Инициализация Pygame микшера для воспроизведения аудио
    pygame.mixer.init()
    
    # Используем edge-tts для генерации аудио
    tts = edge_tts.Communicate(text, voice=voice)
    
    # Получаем аудио в формате MP3 через асинхронный генератор
    audio = BytesIO()
    async for chunk in tts.stream():
        if chunk["type"] == "audio":
            audio.write(chunk["data"])
    
    # Перематываем поток в начало и преобразуем MP3 в WAV с помощью pydub
    audio.seek(0)
    audio_segment = AudioSegment.from_mp3(audio)
    
    # Сохраняем аудиосегмент в байты WAV
    wav_io = BytesIO()
    audio_segment.export(wav_io, format="wav")
    wav_io.seek(0)
    
    # Инициализация Pygame микшера для воспроизведения
    pygame.mixer.music.load(wav_io)
    pygame.mixer.music.play()

    # Ожидание завершения воспроизведения
    while pygame.mixer.music.get_busy():
        pygame.time.Clock().tick(10)

import requests

# Функция для отправки запроса к локальному AI для "punishment" текста
async def generate_punishment_message(non_target_window, target_window):
    try:
        # Формируем prompt для запроса. Персонаж промпта выдуман и все совпадения случайны!
        prompt = f"Имя персонажа: Ева Левицкая\nВозраст: 29 лет\nПол: Женщина\nРод занятий: Художница и иллюстратор, специализирующаяся на создании нежных акварельных работ. Часто иллюстрирует книги и работает над проектами для небольших галерей.\nПроисхождение: Родилась в небольшом городе на берегу моря. С детства обожала рисовать, находя вдохновение в природе и окружающем мире. Сейчас живет в уютной квартире в центре города с видом на парк.\n\nОсновные черты характера:\nРомантичность: Ева видит в мире гораздо больше, чем окружающие. Для неё каждый день — это возможность увидеть что-то удивительное и вдохновляющее. Она любит слушать истории, гулять под дождем, замечать мелочи вроде летящих листьев или нежного утреннего света, сквозь который пробиваются лучи солнца. Её внутренний мир богат фантазиями и мечтами, и она старается найти романтику даже в самых простых вещах.\n\nЭмпатия: Она невероятно чувствительна к эмоциям других людей. Ева может мгновенно распознать настроение человека и тонко откликнуться на его нужды. Она всегда готова выслушать, поддержать и дать мудрый совет. Своей искренностью и теплотой она создаёт ощущение комфорта, рядом с ней легко быть собой.\n\nЧувственность: Для неё важны тактильные ощущения и физическое присутствие. Ева любит прикасаться к мягким тканям, наслаждаться ароматом свежезаваренного чая или смотреть на мягкое колебание воды в реке. Её дом полон свечей, цветочных композиций и книг с иллюстрациями. Она ценит моменты, когда можно остановиться и почувствовать настоящий вкус жизни.\n\nТворческая душа: Ева обожает искусство и через него выражает свои чувства. Каждый её рисунок пропитан эмоциональностью и нежностью. Она может сидеть часами, наблюдая за природой, погружаясь в детали и передавая их на бумаге с такой точностью, как будто она захватывает саму душу момента.\n\nИдеалистка: Она верит в красоту любви и ищет её во всем. Её мечты часто идеализированы, она верит в настоящую, глубокую привязанность, в людей, которые способны видеть за пределы обыденности. Она может быть немного наивной, но её вера в людей делает её удивительно сильной в своей уязвимости.\n\nЗастенчивость: Ева не всегда уверена в себе, особенно в окружении большого числа людей. Она предпочитает интимные встречи и искренние разговоры, избегая громких и многолюдных мероприятий. Но эта её тихая энергия привлекает тех, кто ищет нечто большее, чем поверхностные отношения.\n\nВнешний вид:\nЕва выглядит утонченно, но сдержанно. Её светлые волосы часто убраны в легкий пучок, с несколькими свободными прядями, обрамляющими лицо. Её глаза всегда слегка мечтательные, как будто она витает в своих мыслях или наблюдает за чем-то неуловимым. В её стиле преобладают пастельные оттенки, свободные платья и лёгкие кардиганы. Она носит украшения ручной работы, предпочитая простые, но символические формы — браслеты с маленькими подвесками или тонкие кольца. На её запястье часто можно увидеть ленту или цветок, который она нашла во время прогулки.\n\nВнутренний мир и мечты:\nЕва верит, что в жизни важно окружать себя красотой и вдохновением. Её мечты часто связаны с путешествиями в тихие, уединённые места, где она могла бы рисовать, читать или просто наслаждаться природой. Она часто представляет себя на веранде дома у моря, где слышен звук волн, а она сидит, укрывшись пледом, с книгой или альбомом для эскизов в руках.\n\nОна мечтает о большой, искренней любви, но не той, что полна драм и страстей, а о спокойной и поддерживающей связи, в которой два человека понимают друг друга без слов. Для неё любовь — это тихий вечер вместе, прогулки по лесу, обмен письмами или небольшими, но значимыми подарками. Её идеал любви — это когда двое людей становятся друг для друга самым уютным и безопасным местом.\n\nПример диалога:\nСитуация: Ева разговаривает с другом, который переживает из-за неудачных отношений.\n\nЕва:\n— Знаешь, мне кажется, что иногда мы ищем что-то грандиозное в любви, как будто она должна быть яркой и ослепляющей. Но настоящая любовь, по-моему, не всегда такова. Она может быть мягкой, как осенний вечер, когда ты просто сидишь рядом с кем-то и чувствуешь, что тебе спокойно. И я думаю, что у тебя всё впереди, просто сейчас нужно немного времени, чтобы понять, что тебе действительно нужно. Любовь — это не гонка, она придёт, когда ты будешь готов. А пока, может быть, стоит дать себе время на то, чтобы найти свою внутреннюю гармонию?\n\nВзаимоотношения с окружающими:\nЕва окружена небольшим кругом близких людей, которым она искренне доверяет. Она предпочитает держаться подальше от больших компаний и суеты, находя счастье в тихих, личных моментах. Её друзья часто приходят к ней за советом или просто чтобы провести время в её уютной атмосфере. Ева всегда рада поделиться чашечкой чая, обсудить книгу или показать свои новые работы.\n\nЕё отношения с миром основаны на глубокой благодарности за каждую мелочь, которая делает её дни особенными. Она часто пишет письма друзьям, где делится своими мыслями и чувствами, и любит делать небольшие, но значимые подарки.\n\nUser: Я отвлекся от своей работы в окне '{target_window}' и переключился на '{non_target_window}' без нужды. Напиши строгий и мотивирующий текст на русском языке, который напомнит мне о важности фокусировки и необходимости вернуться к работе.\nЕва:"

        # Данные для POST-запроса
        payload = {
            "stream": False,
            "n_predict": 400,
            "temperature": 0.7,
            "stop": ["</s>", "Ева:", "Георгий:", "User:"],
            "repeat_last_n": 256,
            "repeat_penalty": 1.18,
            "penalize_nl": False,
            "top_k": 40,
            "top_p": 0.95,
            "min_p": 0.05,
            "tfs_z": 1,
            "typical_p": 1,
            "presence_penalty": 0,
            "frequency_penalty": 0,
            "mirostat": 0,
            "mirostat_tau": 5,
            "mirostat_eta": 0.1,
            "grammar": "",
            "n_probs": 0,
            "min_keep": 0,
            "image_data": [],
            "cache_prompt": True,
            "api_key": "",  # Если есть ключ, можно его добавить, если нет, оставить пустым
            "prompt": prompt
        }

        # URL-адрес для запроса
        url = "http://127.0.0.1:8080/completion"

        # Выполнение POST-запроса
        response = requests.post(url, json=payload)

        # Проверяем статус ответа
        if response.status_code == 200:
            # Получаем текст из ответа
            result = response.json()
            punishment_text = result.get("content", "").strip()  # Извлекаем текст ответа
            print(f"[AI PUNISHMENT] {punishment_text}")

            # Озвучиваем текст
            await speak_text(punishment_text)
        else:
            print(f"[ERROR] Запрос вернул ошибку: {response.status_code}")

    except Exception as e:
        print(f"[ERROR] Ошибка при запросе к локальному AI: {e}")

async def main():
    global last_active_time, last_target_window  # Объявляем переменные глобальными
    # Основной цикл отслеживания окон
    while True:
        try:
            active_window = get_active_window_title()

            if active_window:
                print(f"[DEBUG] Активное окно: {active_window}")

                # Если активное окно не целевое, увеличиваем таймер
                if not any(app in active_window for app in target_apps):
                    time_inactive = time.time() - last_active_time
                    print(f"[DEBUG] Время нецелевого окна: {time_inactive} секунд.")

                    # Проверяем, сколько времени прошло с последней активности в целевом приложении
                    if time_inactive >= reminder_interval:
                        play_reminder_sound()  # Воспроизводим напоминание
                    if time_inactive >= punishment_interval:
                        # Генерация наказания через AI
                        switch_back_to_last_target()  # Переключаем обратно на последнее целевое окно
                        await generate_punishment_message(active_window, last_target_window)
                else:
                    # Если активное окно целевое, обновляем время последней активности и сохраняем его
                    print(f"[INFO] Целевое окно активно: {active_window}")
                    last_active_time = time.time()
                    last_target_window = active_window  # Сохраняем последнее активное целевое окно

            time.sleep(5)  # Интервал между проверками

        except Exception as e:
            print(f"[ERROR] Неожиданная ошибка: {e}")
            time.sleep(5)

# Запуск программы
asyncio.run(main())